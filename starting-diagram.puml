@startuml
/'
I know classes aren't really a thing in Rust
but it helps me to think about the structure.
This is really not data-driven.
I'll try and update this as I go
'/

class Dag {
  TaskNode start_node
  {field} Graph<TaskNode> graph_nodes
  NodeId get_node(node_id)
  bool contains_node(node_id)
  add_task(task_node, parents, children)
  set_starting_node(node_id)
}

class TaskNode {
  NodeId id_node
  TaskDefinition definition
  TaskInstance instance
  TaskRunner runner
  {method} Result<(), Error> run()
  bool complete()
  {method} Option<TaskOutput> output()
}

interface TaskDefinition {
  TaskId task_definition_id()
  {method} Result<(), Error> run()
  {method} HashMap<String, String> get_params()
}

interface TaskRunner {
  RunnerId 
}

enum TaskStatus {
  Queued
  Running
  Success
  Failure
}

interface TaskRunner

class TaskInstance

' TaskDefinition implementations
class TaskPython
class TaskBash
interface TaskDataTransfer
class TaskPostgresToCsv

TaskPython -up-> TaskDefinition
TaskBash -up-> TaskDefinition
TaskDataTransfer -up-> TaskDefinition
TaskPostgresToCsv -up-> TaskDataTransfer

' TaskRunner implementations
class LocalRunner
class RemoteRunner
LocalRunner -up-> TaskRunner
RemoteRunner -up-> TaskRunner

' TaskDefinition -right-> TaskRunner
' TaskRunner -right-> TaskInstance

' TaskStatus .down.> TaskInstance
TaskNode -> Dag
TaskDefinition -> TaskNode

@enduml
